1. Because boot.S and mpentry.S zero %ds, they must both run from addresses in the low 2^16 bytes of physical memory. In boot.S, this has no problem using labels directly, because the link address is the same as the load address; however, in mpentry.S, the code is linked above KERNBASE. Therefore, to reference the absolute addresses of the symbols in mpentry.S, it needs to use the MPBOOTPHYS macro to identify where these addresses are in relation to MPENTRY_ADDR (where the code is loaded).
2. Each CPU needs an individual kernel stack to accomodate the possibility of simulatenous syscalls from different processes. If this didn't exist, and a process in kernel mode was blocked on user input, it could give up the CPU and then have its stack modified by another process in kernel mode, interrupting the code flow in the first CPU.
3. The pointer e is in the kernel virtual address space, which is copied and equal across all addressing contexts (page directories). Therefore, the dereference returns the same value for e in all addressing switches, so it is unaffected by the call to lcr3.
4. This is necessary so the old environment can stop and resume running at any time without having to account for the possibility of its registers being overwritten. This happens automatically when the process enters kernel mode (either by calling yield or by a timer interrupt) via the pushal instruction in trapentry.S.
