1. Because boot.S and mpentry.S zero %ds, they must both run from addresses in the low 2^16 bytes of physical memory. In boot.S, this has no problem using labels directly, because the link address is the same as the load address; however, in mpentry.S, the code is linked above KERNBASE. Therefore, to reference the absolute addresses of the symbols in mpentry.S, it needs to use the MPBOOTPHYS macro to identify where these addresses are in relation to MPENTRY_ADDR (where the code is loaded).
2. Each CPU needs an individual kernel stack to accomodate the possibility of simulatenous syscalls from different processes. If this didn't exist, and a process in kernel mode was blocked on user input, it could give up the CPU and then have its stack modified by another process in kernel mode, interrupting the code flow in the first CPU.
3. The pointer e is in the kernel virtual address space, which is copied and equal across all addressing contexts (page directories). Therefore, the dereference returns the same value for e in all addressing switches, so it is unaffected by the call to lcr3.
4. This is necessary so the old environment can stop and resume running at any time without having to account for the possibility of its registers being overwritten. This happens automatically when the process enters kernel mode (either by calling yield or by a timer interrupt) via the pushal instruction in trapentry.S.

Challenge:
I implemented the parallel matrix-multiplication scheme using multiple processes described in ``Communicating Sequential Processes'' (Hoare 1978). The paper describes the layout of the algorithm well and I followed it essentially exactly; therefore, I shall talk about the JOS-specific aspects of my implementation. 
The main change I made was the implementation of a new interface to the ipc_recv system call: ipc_recv_select which allows for `selective receiving': an environment `A' can specify an envid `B' to ipc_recv, and then will only allow that corresponding environment with id `B' to send to it. All other environments will block without error, as if `A' was simply not receiving at all. This is necessary to ensure consistent ordering of values being sent and received between processes, beyond what is possibly through the original interface. The original system call for ipc_recv was left unchanged to allow for backwards compatibility.
Accordingly, I needed a two-step process for setting up the child processes: I created them all, then had the parent send them all the envids of their neighboring nodes. This allowed the nodes in the graph to gain knowledge and specify which environments they should send to or receive from.
